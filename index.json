[{"content":"随着摩尔定律失效，现在的CPU硬件开始往着多核的发向发展。熟悉多任务处理的朋友肯定对多线程（Multithreading）和多进程（Multiprocessing）非常了解。\n但是多线程和多进程的开发模式，内存占用高，线程进程切换成本等原因，导致效率低下。\n📌 但是同时现代操作系统都是抢占式，系统线程会相互争夺资源，如何让整体更高效成为了我们需要思考的问题。\n操作系统级线程和绿色线程 操作系统级线程（OS-level thread） 程序执行在操作系统上都是由进程（Process）来负责的，而线程（Thread）是进程的组成单元。在现代操作系统中，线程又会被细分为用户级线程（User thread）和内核级线程（Kernel thread）。而这样做的好处是：\n 更高的效率：区分了用户级线程和内核级线程以后，用户线程轻量且内核不感知，切换成本低。而内核级线程专注于CPU/内核的沟通上。两者各司其职，效率比以往有提升。 更好的安全性：内核级线程和用户级线程权限不同，从用户级线程进入内核线程方法有限，例如I/O调用。并且用不同的namespace进行隔离，提升了安全性。   当然，这样也导致了原来普通的线程执行在现在的模式下，涉及到用户级线程和内核级线程的切换，权衡利弊。\n 绿色线程 （Green thread） 绿色线程的名称来源于最初的Java线程库。这是因为 甲骨文公司的「绿色团队」最初设计了Java 的线程库。绿色线程是一种由运行环境或虚拟机(VM)调度，而不是由本地底层操作系统调度的线程。\n据此进行拓展，各种语言都有尝试实现自己的所谓的“绿色线程”。例如，Python的 greenlet, Golang的 goroutine。这些语言实现通过自定义数据格式，可以实现更小尺寸的数据结构，从而产生数量远大于一般操作系统级线程的数量上限，提高并行处理的效率。\n线程模型 上文所说现代操作系统大多都将线程划分成了用户级线程（User thread）和内核级线程（Kernel thread）。如何去匹配两者让两者协同工作就成了一个问题，线程模型（Thread modeling）就是用于解决这个问题。\n1:1 内核级线程型 这种模型保证一个用户线程对应一个内核线程，这也是最简单的模型。这种方法被Solaris, NetBSD, FreeBSD, macOS, 和 iOS 采用。\nN:1 用户级线程型 一个N：1的用户级线程模型是多个用户级线程对应一个内核线程。用户级线程的轻量导致在这个层面切换成本低，调度器实现简单。但同时此模型无法有效利用多核心处理器：例如多个用户线程需要访问I/O必须通过内核线程，此时就会出现争夺，导致阻塞。\nN:M 混合型 N：M混合模型是介于上面两者之间的一种解决方法。在这种情况下我们需要比较复杂的算法去处理调度器高效运作，提升处理效率。\n💡 上面描述的是系统层面的，我们可以推导出，在语言层面绿色线程也可以做到类似功能的事情。 例如，Python则采用的是N：1模型。Golang才用的是N：M的模型 Python实战 协程非常适合与其他一些程序组件一起使用，例如协作任务，异常，事件循环，迭代器和无限队列等. Python 3.4版本引入异步IO的标准库asyncio，使用事件循环驱动协程实现并发。 在asyncio库中，用asyncio.coroutine装饰，用yield from来驱动协程 Python 3.5版本中 用async代替了asyncio.coroutine，用await代替了yield from。\nimport threading import asyncio @asyncio.coroutine def hello(): print(\u0026#39;Hello world! (%s)\u0026#39; % threading.currentThread()) yield from asyncio.sleep(1) print(\u0026#39;Hello again! (%s)\u0026#39; % threading.currentThread()) loop = asyncio.get_event_loop() tasks = [hello(), hello()] loop.run_until_complete(asyncio.wait(tasks)) loop.close() 运行结果如下：\n(blog):Desktop siyao$ python example.py Hello world! (\u0026lt;_MainThread(MainThread, started 4673900032)\u0026gt;) Hello world! (\u0026lt;_MainThread(MainThread, started 4673900032)\u0026gt;) Hello again! (\u0026lt;_MainThread(MainThread, started 4673900032)\u0026gt;) Hello again! (\u0026lt;_MainThread(MainThread, started 4673900032)\u0026gt;) \n\n参考   ","permalink":"https://ayaoayao.github.io/posts/2021-05-07/","summary":"随着摩尔定律失效，现在的CPU硬件开始往着多核的发向发展。熟悉多任务处理的朋友肯定对多线程（Multithreading）和多进程（Multiprocessing）非常了解。\n但是多线程和多进程的开发模式，内存占用高，线程进程切换成本等原因，导致效率低下。\n📌 但是同时现代操作系统都是抢占式，系统线程会相互争夺资源，如何让整体更高效成为了我们需要思考的问题。\n操作系统级线程和绿色线程 操作系统级线程（OS-level thread） 程序执行在操作系统上都是由进程（Process）来负责的，而线程（Thread）是进程的组成单元。在现代操作系统中，线程又会被细分为用户级线程（User thread）和内核级线程（Kernel thread）。而这样做的好处是：\n 更高的效率：区分了用户级线程和内核级线程以后，用户线程轻量且内核不感知，切换成本低。而内核级线程专注于CPU/内核的沟通上。两者各司其职，效率比以往有提升。 更好的安全性：内核级线程和用户级线程权限不同，从用户级线程进入内核线程方法有限，例如I/O调用。并且用不同的namespace进行隔离，提升了安全性。   当然，这样也导致了原来普通的线程执行在现在的模式下，涉及到用户级线程和内核级线程的切换，权衡利弊。\n 绿色线程 （Green thread） 绿色线程的名称来源于最初的Java线程库。这是因为 甲骨文公司的「绿色团队」最初设计了Java 的线程库。绿色线程是一种由运行环境或虚拟机(VM)调度，而不是由本地底层操作系统调度的线程。\n据此进行拓展，各种语言都有尝试实现自己的所谓的“绿色线程”。例如，Python的 greenlet, Golang的 goroutine。这些语言实现通过自定义数据格式，可以实现更小尺寸的数据结构，从而产生数量远大于一般操作系统级线程的数量上限，提高并行处理的效率。\n线程模型 上文所说现代操作系统大多都将线程划分成了用户级线程（User thread）和内核级线程（Kernel thread）。如何去匹配两者让两者协同工作就成了一个问题，线程模型（Thread modeling）就是用于解决这个问题。\n1:1 内核级线程型 这种模型保证一个用户线程对应一个内核线程，这也是最简单的模型。这种方法被Solaris, NetBSD, FreeBSD, macOS, 和 iOS 采用。\nN:1 用户级线程型 一个N：1的用户级线程模型是多个用户级线程对应一个内核线程。用户级线程的轻量导致在这个层面切换成本低，调度器实现简单。但同时此模型无法有效利用多核心处理器：例如多个用户线程需要访问I/O必须通过内核线程，此时就会出现争夺，导致阻塞。\nN:M 混合型 N：M混合模型是介于上面两者之间的一种解决方法。在这种情况下我们需要比较复杂的算法去处理调度器高效运作，提升处理效率。\n💡 上面描述的是系统层面的，我们可以推导出，在语言层面绿色线程也可以做到类似功能的事情。 例如，Python则采用的是N：1模型。Golang才用的是N：M的模型 Python实战 协程非常适合与其他一些程序组件一起使用，例如协作任务，异常，事件循环，迭代器和无限队列等. Python 3.4版本引入异步IO的标准库asyncio，使用事件循环驱动协程实现并发。 在asyncio库中，用asyncio.coroutine装饰，用yield from来驱动协程 Python 3.5版本中 用async代替了asyncio.coroutine，用await代替了yield from。\nimport threading import asyncio @asyncio.coroutine def hello(): print(\u0026#39;Hello world! (%s)\u0026#39; % threading.","title":"初窥”协程“之Python"},{"content":"随笔 今天给新人出面试题的时候，想到自己也可能要跳槽了。也许面临的也是这样的考试还是为自己捏了一把汗。有一段时间沉浸于业务当中导致自己的视野被限制，创新能力的下降。是时候把别的东西捡起来看看了。\n待做列表  更新简历 熟悉 markdown 熟悉 docker compose 熟悉 机器学习 熟悉 golang 基础语法 熟悉 python 图像处理  每日一题算法 实现LFU算法对象\n#!/usr/bin/env python  from collections import deque class LFUCache(object): def __init__(self, num): self.cap = num self.dict = {} self.stack = deque([]) def get(self, key): if key in self.dict: self.stack.append(key) return self.dict[key] return -1 def set(self, key, value): if key not in self.dict and len(self.dict) \u0026gt;= self.cap: pivot = self.stack.popleft() self.dict.pop(pivot) self.dict[key] = value self.stack.append(key) return \u0026#39;\u0026#39; 主要利用了 collections 模块里的 deque 队列，FIFO帮助我们模拟了实际上的队列操作，并且记录下来了整个操作过程\n","permalink":"https://ayaoayao.github.io/posts/2021-04-28/","summary":"随笔 今天给新人出面试题的时候，想到自己也可能要跳槽了。也许面临的也是这样的考试还是为自己捏了一把汗。有一段时间沉浸于业务当中导致自己的视野被限制，创新能力的下降。是时候把别的东西捡起来看看了。\n待做列表  更新简历 熟悉 markdown 熟悉 docker compose 熟悉 机器学习 熟悉 golang 基础语法 熟悉 python 图像处理  每日一题算法 实现LFU算法对象\n#!/usr/bin/env python  from collections import deque class LFUCache(object): def __init__(self, num): self.cap = num self.dict = {} self.stack = deque([]) def get(self, key): if key in self.dict: self.stack.append(key) return self.dict[key] return -1 def set(self, key, value): if key not in self.dict and len(self.dict) \u0026gt;= self.cap: pivot = self.stack.popleft() self.","title":"面试的感悟和每日算法"}]