[{"content":"敏捷开发 VS 瀑布式开发 在早期软件开发的时候，往往采取的是瀑布式开发流程。这种开发模式需要在计划的早期就定义好需求，目标以及服务市场。\n而在当今软件行业，需要对市场的各种需求形成及时反馈时，敏捷开发模式 应运而生。\n为了赢得市场，我们不得不接连开发一个又一个新功能。同时，新的挑战也应运而生。\n 如何确保新功能工作正常？如何保证新功能不会影响已有的功能？如何确保产品的总体质量？\n 什么是DevOps？ 上文提到了敏捷开发模式。为了保证在开发过程中，不同的工作之间减小依赖，提升效率，我们将不同的部分进行了职责细化:\n 开发（Development） 测试（QA） 运维（Operations）  而他们之间沟通的桥梁就是DevOps。如右图所示：\n\n\n在现代的软件开发中，我们将上述步骤与业务连接起来，得到如下图所示的开发流程。\n我们可以清晰的看到，开发的过程中，从计划 \u0026ndash;\u0026gt; 源码 \u0026ndash;\u0026gt; 测试 （QA介入）\u0026ndash;\u0026gt; 发布 \u0026ndash;\u0026gt; 部署 \u0026ndash;\u0026gt; 维护 \u0026ndash;\u0026gt; 监控的完整生命周期。\n简而言之，即是开发 \u0026ndash;\u0026gt; 测试 \u0026ndash;\u0026gt; 发布 \u0026ndash;\u0026gt; 市场反馈 的一个流程。\n为什么说“数据为王”？  Question: 划分不同的职能，职能直接任务交接的时候，沟通无法避免。背景知识和职业技能的差别会导致叫沟通成本激增。我们该怎么处理？\n 我们不妨从数据角度对DevOps的步骤进行分析，可以得到 源码 \u0026ndash;\u0026gt; 测试用例 \u0026ndash;\u0026gt; 测试结果 \u0026ndash;\u0026gt; 项目待办事项 这样一条数据的隐线。每个职能对应处理这条数据隐线上的一块儿，而这种沟通成本即是如何将这些不同的数据/语言进行翻译的过程。\n通过建立一个完整的产品质量监控平台，从源码的生成到最后部署到最后的项目待办事项。开发，测试，运维，包括项目经理等，通过可视化的方式。用图片，网站来展示每一部分的数据，从而达到最直观的效果。\n并且，源码，测试用例，测试结果，项目待办事项都是我们的数据资产的一部分。如何管理好我们的数据资产帮助我们提升产品竞争力，也是非常重要的一环。\n一些其他的反思 正常的软件开发流程就如DevOps图中所展示的这样，但是，我们如果将顺序反过来的话。能得到一些什么样的结果呢？\n度量测试的有效性 设想以下的问题：\n  这么多的CASE，花了大量时间和资源去运行，真能发现BUG吗? CI做到90%的行覆盖率了，能发现问题吗? 测试用例越来越多，删一些，会不会就发现不了问题了? 怎么找出那些为了覆盖而覆盖，发现不了真正问题 的测试用例?   通过反转，我们得到源码 \u0026lt;\u0026ndash; 测试用例 \u0026lt;\u0026ndash; 测试结果 这条的子流程。 向代码注入变异，经过DevOps 质量平台验证以后的测试结果，与理论结果进行对比。过滤到那些不能发现问题的测试用例，删除不能发现问题的测试用例。对测试用例资产进行管理，将“测试用例负债”转换成我们真正可用的资源。\n其他？  内存注入 静态扫描 链路扫描 \u0026hellip;  ","permalink":"https://ayaoayao.github.io/posts/2021-05-17/","summary":"敏捷开发 VS 瀑布式开发 在早期软件开发的时候，往往采取的是瀑布式开发流程。这种开发模式需要在计划的早期就定义好需求，目标以及服务市场。 而在当今软","title":"DevOps“数据为王”"},{"content":"随着摩尔定律失效，现在的CPU硬件开始往着多核的发向发展。熟悉多任务处理的朋友肯定对多线程（Multithreading）和多进程（Multiprocessing）非常了解。\n但是多线程和多进程的开发模式，内存占用高，线程进程切换成本等原因，导致效率低下。\n📌 但是同时现代操作系统都是抢占式，系统线程会相互争夺资源，如何让整体更高效成为了我们需要思考的问题。\n操作系统级线程和绿色线程 操作系统级线程（OS-level thread） 程序执行在操作系统上都是由进程（Process）来负责的，而线程（Thread）是进程的组成单元。在现代操作系统中，线程又会被细分为用户级线程（User thread）和内核级线程（Kernel thread）。而这样做的好处是：\n 更高的效率：区分了用户级线程和内核级线程以后，用户线程轻量且内核不感知，切换成本低。而内核级线程专注于CPU/内核的沟通上。两者各司其职，效率比以往有提升。 更好的安全性：内核级线程和用户级线程权限不同，从用户级线程进入内核线程方法有限，例如I/O调用。并且用不同的namespace进行隔离，提升了安全性。   当然，这样也导致了原来普通的线程执行在现在的模式下，涉及到用户级线程和内核级线程的切换，权衡利弊。\n 绿色线程 （Green thread） 绿色线程的名称来源于最初的Java线程库。这是因为 甲骨文公司的「绿色团队」最初设计了Java 的线程库。绿色线程是一种由运行环境或虚拟机(VM)调度，而不是由本地底层操作系统调度的线程。\n据此进行拓展，各种语言都有尝试实现自己的所谓的“绿色线程”。例如，Python的 greenlet, Golang的 goroutine。这些语言实现通过自定义数据格式，可以实现更小尺寸的数据结构，从而产生数量远大于一般操作系统级线程的数量上限，提高并行处理的效率。\n线程模型 上文所说现代操作系统大多都将线程划分成了用户级线程（User thread）和内核级线程（Kernel thread）。如何去匹配两者让两者协同工作就成了一个问题，线程模型（Thread modeling）就是用于解决这个问题。\n1:1 内核级线程型 这种模型保证一个用户线程对应一个内核线程，这也是最简单的模型。这种方法被Solaris, NetBSD, FreeBSD, macOS, 和 iOS 采用。\nN:1 用户级线程型 一个N：1的用户级线程模型是多个用户级线程对应一个内核线程。用户级线程的轻量导致在这个层面切换成本低，调度器实现简单。但同时此模型无法有效利用多核心处理器：例如多个用户线程需要访问I/O必须通过内核线程，此时就会出现争夺，导致阻塞。\nN:M 混合型 N：M混合模型是介于上面两者之间的一种解决方法。在这种情况下我们需要比较复杂的算法去处理调度器高效运作，提升处理效率。\n💡 上面描述的是系统层面的，我们可以推导出，在语言层面绿色线程也可以做到类似功能的事情。 例如，Python则采用的是N：1模型。Golang才用的是N：M的模型 Python实战 协程非常适合与其他一些程序组件一起使用，例如协作任务，异常，事件循环，迭代器和无限队列等. Python 3.4版本引入异步IO的标准库asyncio，使用事件循环驱动协程实现并发。 在asyncio库中，用asyncio.coroutine装饰，用yield from来驱动协程 Python 3.5版本中 用async代替了asyncio.coroutine，用await代替了yield from。\nimport threading import asyncio @asyncio.coroutine def hello(): print(\u0026#39;Hello world! (%s)\u0026#39; % threading.currentThread()) yield from asyncio.sleep(1) print(\u0026#39;Hello again! (%s)\u0026#39; % threading.currentThread()) loop = asyncio.get_event_loop() tasks = [hello(), hello()] loop.run_until_complete(asyncio.wait(tasks)) loop.close() 运行结果如下：\n(blog):Desktop siyao$ python example.py Hello world! (\u0026lt;_MainThread(MainThread, started 4673900032)\u0026gt;) Hello world! (\u0026lt;_MainThread(MainThread, started 4673900032)\u0026gt;) Hello again! (\u0026lt;_MainThread(MainThread, started 4673900032)\u0026gt;) Hello again! (\u0026lt;_MainThread(MainThread, started 4673900032)\u0026gt;) \n\n参考   ","permalink":"https://ayaoayao.github.io/posts/2021-05-07/","summary":"随着摩尔定律失效，现在的CPU硬件开始往着多核的发向发展。熟悉多任务处理的朋友肯定对多线程（Multithreading）和多进程（Mult","title":"初窥”协程“之Python"},{"content":"随笔 今天给新人出面试题的时候，想到自己也可能要跳槽了。也许面临的也是这样的考试还是为自己捏了一把汗。有一段时间沉浸于业务当中导致自己的视野被限制，创新能力的下降。是时候把别的东西捡起来看看了。\n待做列表  更新简历 熟悉 markdown 熟悉 docker compose 熟悉 机器学习 熟悉 golang 基础语法 熟悉 python 图像处理  每日一题算法 实现LFU算法对象\n#!/usr/bin/env python  from collections import deque class LFUCache(object): def __init__(self, num): self.cap = num self.dict = {} self.stack = deque([]) def get(self, key): if key in self.dict: self.stack.append(key) return self.dict[key] return -1 def set(self, key, value): if key not in self.dict and len(self.dict) \u0026gt;= self.cap: pivot = self.stack.popleft() self.dict.pop(pivot) self.dict[key] = value self.stack.append(key) return \u0026#39;\u0026#39; 主要利用了 collections 模块里的 deque 队列，FIFO帮助我们模拟了实际上的队列操作，并且记录下来了整个操作过程\n","permalink":"https://ayaoayao.github.io/posts/2021-04-28/","summary":"随笔 今天给新人出面试题的时候，想到自己也可能要跳槽了。也许面临的也是这样的考试还是为自己捏了一把汗。有一段时间沉浸于业务当中导致自己的视野被","title":"面试的感悟和每日算法"}]